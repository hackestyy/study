///////////////////////////////////////////////////////////
//  Behavior.cs
//  Implementation of the Class Behavior
//  Generated by Enterprise Architect
//  Created on:      20-十二月-2011 10:13:32
//  Original author: zhanghao
///////////////////////////////////////////////////////////


/*===========================================================================
                             Edit History
    when       who     what, where, why
    --------   ---     ----------------------------------------------------------
 *  
===========================================================================*/
using Speck.Core;
using System;
using System.Threading;
using System.Collections.Generic;

namespace Speck.Core {
	public class Behavior : Component,IDisposable {
        private readonly static object mSyncRoot = new object();
        private Thread mAsynchronousWorkThread;
        protected ManualResetEvent mManualEvent;
        protected BehaviorExcutePattern mBehaviorExcutePattern;
        private EventArgs mDummyEventArgs;
		private Dictionary<Component,BehaviorEntityType> mBehaviorEntities;
        private BehaviorStatus mStatus;
        protected bool mShouldPause = false;
        protected bool mShouldAbort = false;
        protected bool mIsWorkFinished=false;
        // Track whether Dispose has been called.
        private bool mDisposed = false;


        public Behavior()
        {
            Initialize();
        }

        ~Behavior()
        {
            Dispose(false);
        }

		public virtual void Abort(){
            mManualEvent.Set();
            mShouldAbort = true;
		}

		protected virtual void Close(){


            mStatus = BehaviorStatus.Closed;
            mShouldPause = false;
            mShouldPause = false;
            OnClosed();
            if (mAsynchronousWorkThread != null)
            {
                mAsynchronousWorkThread.Join();
            }
		}

		protected virtual void ExcuteAsynchronously(){
            throw new NotImplementedException();

		}

		protected virtual void ExcuteSynchronously(){
            throw new NotImplementedException();
		}

		protected virtual void OnAborted(){
            if (Aborted != null)
            {
                Aborted(this, mDummyEventArgs);
            }
            Close();
		}

		protected virtual void OnBeforeStart()
        {
            if (BeforeStart != null)
            {
                BeforeStart(this, mDummyEventArgs);
            }
		}

		protected virtual void OnClosed(){
            if(Closed!=null)
            {
                Closed(this, mDummyEventArgs);
            }
		}

		/// <summary>
		/// Rewrite to provide the behavior of customization
		/// </summary>
		protected virtual void OnPause(){
            mStatus = BehaviorStatus.Paused;
            if (Paused != null)
            {
                Paused(this,mDummyEventArgs);
            }
		}

		protected virtual void OnResumed(){
            mStatus = BehaviorStatus.Working;
            if (Resumed != null)
            {
                Resumed(this,mDummyEventArgs);
            }
		}

		public virtual void Pause(){
            mShouldPause = true;
            mManualEvent.Reset();
		}

		public virtual void Resume()
        {
            mShouldPause = false;
            mManualEvent.Set();
		}


        /// <summary>
        /// Starts the behavior with the specified synchronization pattern.
        /// </summary>
        /// <param name="synchronizationPattern">The synchronization pattern.</param>
		public virtual void Start(BehaviorExcutePattern synchronizationPattern)
        {
            OnBeforeStart();
            switch (synchronizationPattern)
            {
                case BehaviorExcutePattern.Synchronization:
                    mBehaviorExcutePattern = BehaviorExcutePattern.Synchronization;
                    //ExcuteSynchronously();
                    Work();
                    break;
                case BehaviorExcutePattern.Asynchronization:
                    lock (mSyncRoot)
                    {
                        if (mAsynchronousWorkThread == null)
                        {
                            mAsynchronousWorkThread = new Thread(Work);
                        }
                    }
                    mBehaviorExcutePattern = BehaviorExcutePattern.Asynchronization;
                    mAsynchronousWorkThread.Start();
                    break;
            }
		}

        public event BeforeStartEventHandler BeforeStart;

        public event PauseEventHandler Pause;

        public event ResumeEventHandler Resumed;

        public event AbortedEventHandler Aborted;

        public event CloseEventHandler Closed;


        public override void Add(Component component)
        {
            throw new NotImplementedException();
        }

        protected override void DoWork()
        {
            throw new NotImplementedException();
        }

        public override void Initialize()
        {
            mDummyEventArgs = new EventArgs();
            mStatus = BehaviorStatus.Closed;
            //initialize the event state to allow thread to continue
            mManualEvent = new ManualResetEvent(true);
            mBehaviorEntities = new Dictionary<Component, BehaviorEntityType>();
        }

        public override void Remove(Component component)
        {
            throw new NotImplementedException();
        }

        public override void Work()
        {
            mStatus = BehaviorStatus.Working;
            DoWork();
        }

		public Dictionary<Component,BehaviorEntityType> BehaviorEntities{
			get{
				return mBehaviorEntities;
			}
		}

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!this.mDisposed)
            {
                if (disposing)
                {
                    // Free other state (managed objects).

                }
                // Free your own state (unmanaged objects).

                //close the work thread
                if (mStatus != BehaviorStatus.Closed)
                {
                    this.Abort();
                }

                

                // Note disposing has been done.
                mDisposed = true;

            }
        }
    }//end Behavior


    public delegate void BeforeStartEventHandler(object sender,EventArgs e);
    public delegate void PauseEventHandler(object sender,EventArgs e);
    public delegate void ResumeEventHandler(object sender,EventArgs e);
    public delegate void AbortedEventHandler(object sender,EventArgs e);
    public delegate void CloseEventHandler(object sender,EventArgs e);

    public enum BehaviorStatus
    { 
        Working,
        Paused,
        Closed
    }//end BehaviorStatuss
}//end namespace Core