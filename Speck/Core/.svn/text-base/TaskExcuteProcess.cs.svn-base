///////////////////////////////////////////////////////////
//  TaskExcuteProcess.cs
//  Implementation of the Class TaskExcuteProcess
//  Generated by Enterprise Architect
//  Created on:      20-十二月-2011 10:55:12
//  Original author: zhanghao
///////////////////////////////////////////////////////////


/*===========================================================================
                             Edit History
    when       who     what, where, why
    --------   ---     ----------------------------------------------------------
 *  2012/7/5   zhanghao   add teminating tasks function when engine need to be ended
===========================================================================*/

using System;
using System.Threading;
using System.Collections.Generic;

namespace ZteApp.ProductService.Core {
	public class TaskExcuteProcess:IDisposable {
        private bool mNeedCancel;
        private Thread mWorkTread;
        private Thread mPoolTread;
        private static readonly Object mSyncRoot=new object();
        private TaskScheduler mTasks;
        private List<Task> mDispatchedTasks;
        private Task mCurrentTask;
        private WorkStatus mEngineState = WorkStatus.Inactive;
        private static TaskExcuteProcess mInstance=null;

        //used to contrl the max concurrent task execution
        private const int mMaxConcurrentTaskCount = 3;
        private int mCurrentTasksCount = 0;

        // to detect redundant calls
        private bool mDisposed=false;
        
        //used for synchronise task execution
        private ManualResetEvent mTaskSpinDoor;
        private AutoResetEvent mTaskPoolSpinDoor;

        private bool mNeedWorkTerminated = false;
        private bool mNeedPoolTerminated = false;
        private bool mInitialized = false;

        private Timer mGuardTimer;
        private const int mPollInterval = 1000;  // ms

        private EventArgs mDummyEventArgs;

        public virtual WorkStatus Status
        {
            get
            {
                return mEngineState;
            }
            protected set
            {
                WorkStatus oldState = mEngineState;
                mEngineState = value;
                if(oldState!=mEngineState)
                {
                    OnStatusChanged();
                }
            }
        }

        public bool NeedWorkTerminated
        {
            get {
                return mNeedWorkTerminated;
            }
            set {
                mNeedWorkTerminated = value;
            }
        }

        public bool NeedPoolTerminated
        {
            get {
                return mNeedPoolTerminated;
            }
            set {
                mNeedPoolTerminated = value;
            }
        }

        public Task[] DispatchedTasks
        {
            get
            {
                return mDispatchedTasks.ToArray();
            }
        }

        public static TaskExcuteProcess Instance
        {
            get
            {
                if (mInstance == null)
                {
                    lock (mSyncRoot)
                    {
                        if (mInstance == null)
                        {
                            mInstance = new TaskExcuteProcess();
                        }
                    }
                }
                return mInstance;
            }
        }

        private TaskExcuteProcess()
        {

            Initialize();
        }

		public void CloseLog(){

		}

		protected virtual void DoWork(){
            
            mCurrentTask.Start();
		}

		private void ExcuteHighRankTask(){

		}

		public void Initialize(){
            if (!mInitialized)
            {
                mWorkTread = new Thread(this.Work);
                mPoolTread = new Thread(this.Pool);
                mNeedCancel = false;
                mTasks = new TaskScheduler();
                mDispatchedTasks = new List<Task>();
                mTaskSpinDoor = new ManualResetEvent(false);
                mTaskPoolSpinDoor = new AutoResetEvent(false);
                mCurrentTasksCount = 0;
                mTasks.TaskRemoved += OnTaskRemovedHandler;
                mTasks.TaskQueued += OnTaskQueuedHandler;
                mGuardTimer = new Timer((object state) => {
                    mTaskPoolSpinDoor.Set();
                }, null, 0, mPollInterval);
                mDummyEventArgs = new EventArgs();
                Status = WorkStatus.Inactive;
                StartLog();

                //StartWork();
                mInitialized = true;
            }
		}

        private void OnTaskRemovedHandler(object sender, TaskEventArgs e)
        {
            OnTaskRemoved(e);
        }

        private void OnTaskQueuedHandler(object sender, TaskEventArgs e)
        {
            //Releaes engine work thread to check if it has work to do
            mTaskSpinDoor.Set();
        }

        protected virtual void OnTaskRemoved(TaskEventArgs e)
        {
            if (TaskRemoved!=null)
            {
                TaskRemoved(this, e);
            }
        }

		protected virtual void OnWorkFinished(){
            Status = WorkStatus.Closed;
            if (WorkFinished != null)
            {
                WorkFinished(this,new TaskExecuteEventArgs(mCurrentTask));
            }
		}

		protected virtual void OnWorkStart(){
            Status = WorkStatus.Working;
            if (WorkStart != null)
            {
                WorkStart(this, new TaskExecuteEventArgs(mCurrentTask));
            }

		}

        protected virtual void OnStatusChanged()
        {
            if (StatusChanged != null)
            {
                StatusChanged(this, mDummyEventArgs);
            }
        }

		public void PollStatus(){

		}

		public void StartLog(){

		}

		public void StartWork(){
            //avoid multi-start here, we use lock
            if (mWorkTread != null && mPoolTread != null)
            {
                Status = WorkStatus.Working;
                mWorkTread.Start();
                mPoolTread.Start();
            }
            else
            {
                throw new Exception("Work thread not available!");
            }
		}

        /// <summary>
        /// Stops the execution engine,yeild stop if all work has been done,
        /// it would not stop if any task is in execution.
        /// </summary>
        public void Stop()
        {
            if (mEngineState != WorkStatus.Closed)
            {
                mNeedPoolTerminated = true;
                mNeedWorkTerminated = true;
                //try to stop the engine
                mTaskSpinDoor.Set();
                mTaskPoolSpinDoor.Set();
                //Dispose();
            }
        }

        /// <summary>
        /// Pools this instance. Used to pool execute engine status
        /// </summary>
        protected virtual void Pool()
        {
            while (!mNeedPoolTerminated)
            {
                mTaskPoolSpinDoor.WaitOne();
                //pool execute engine status here
                mTasks.Schdule();
            }
        }

		protected virtual void Update(){

		}

		private void Work(){
            while(!mNeedWorkTerminated)
            {
                //is any task available or max concurrent tasks reached
                if (mTasks.Count == 0 || mCurrentTasksCount>=mMaxConcurrentTaskCount)
                {
                    mTaskSpinDoor.Reset();
                    mTaskSpinDoor.WaitOne();
                    //awake up by other thread
                    continue;
                }



                ////do task work here
                //get the highest rank task
                mCurrentTask = GetHighestRankTask();

                OnWorkStart();

                DoWork();

                Update();
            }

            //terminate any task if not closed
            foreach (var task in mDispatchedTasks)
            {
                if(task.Status != WorkStatus.Closed)
                {
                    task.Abort();
                }
            }
            bool allTaskClosed = false;
            while (!allTaskClosed)
            {
                Thread.Sleep(mPollInterval);
                //Suppose to be true for bitwise and
                allTaskClosed = true;
                foreach (var task in mDispatchedTasks)
                {
                    allTaskClosed = allTaskClosed && (task.Status == WorkStatus.Closed);
                }
            }

            //All task is down
            OnWorkFinished();

            
		}

        protected virtual Task GetHighestRankTask()
        {
            //here we simple return the fist task in the tasks collection
            if (mTasks == null)
            {
                return null;
            }
            Task dispatchedTask=(mTasks.Get() as Task);
            dispatchedTask.BeforeStart += OnTaskBeforeStartEventHandler;
            dispatchedTask.Closed += OnTaskClosedEventHandler;
            mDispatchedTasks.Add(dispatchedTask);
            mTasks.Remove(dispatchedTask);
            return dispatchedTask;
        }

        ~TaskExcuteProcess()
        {
            Dispose(false);
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!mDisposed)
            {
                if (disposing)
                {
                    //disposing managed resources here
                    mTasks.Clear();
                }
                //disposing unmanaged resources here
                mNeedPoolTerminated = true;
                mNeedWorkTerminated = true;
                mTaskSpinDoor.Set();
                mTaskPoolSpinDoor.Set();
                if (mWorkTread.IsAlive)
                {
                    mWorkTread.Join();
                }
                if (mPoolTread.IsAlive)
                {
                    mPoolTread.Join();
                }
                CloseLog();
                Status = WorkStatus.Closed;
                mDisposed = true;
                mInitialized = false;
            }
        }

        protected virtual void OnTaskClosedEventHandler(object sender, EventArgs e)
        {
            Task task = sender as Task;
            if (task == null)
                return;

            //deal with finished event
            task.Closed -= OnTaskClosedEventHandler;
            task.BeforeStart -= OnTaskBeforeStartEventHandler;
            //release the semaphore that controlling the max concurrent tasks
            mCurrentTasksCount--;
            mTaskSpinDoor.Set();
        }

        protected virtual void OnTaskBeforeStartEventHandler(object sender,EventArgs e)
        {
            //deal with beforeStart event
            Task task = sender as Task;
            if (task == null)
            {
                return;
            }
            //max concurrent task execution control
            mCurrentTasksCount++;
        }

        public void Add(Task task)
        {
            mTasks.Add(task);
            OnTaskAdded(task);
        }

        public void Remove(Task task)
        {
            mTasks.Remove(task);
        }

        protected virtual void OnTaskAdded(Task task)
        {
            if (TaskAdded != null)
            {
                TaskAdded(this, new TaskEventArgs(task));
            }
            //tell engine to work for new comings
            mTaskSpinDoor.Set();
        }

        public event WorkStartEventHandler WorkStart;

        public event WorkFinishedEventHandler WorkFinished;

        public event TaskEventHandler TaskAdded;

        public event TaskEventHandler TaskRemoved;

        public event EventHandler StatusChanged;

        public enum State 
        {
            Running,
            Stopped
        }

    }//end TaskExcuteProcess


    public delegate void WorkStartEventHandler(object sender, TaskExecuteEventArgs e);

    public delegate void WorkFinishedEventHandler(object sender, TaskExecuteEventArgs e);
}//end namespace Core